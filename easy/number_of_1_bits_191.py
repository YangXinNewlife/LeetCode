# -*- coding:utf-8 -*-
__author__ = 'yangxin'
"""
Solutions:
其他的方式比较好理解，这里用最不好理解的汉明重量公式处理（性能最优）：

先理解汉明重量是如何运算的：
input: 0111 1010 0101 0101 0010 0001 1111 0010

step1:  

            0011 1101 0010 1010 1001 0000 1111 1001  (i >> 1)

            0101 0000 0101 0101 0000 0001 0101 0000  (i & 0x55555555)         

            0001 0101 0000 0000 0001 0000 0101 0001 ((i >> 1) & 0x55555555)

            0110 0101 0101 0101 0001 0001 1010 0001 (+)

            剖析下前面的4位 0110  ，01表示input 前2位有1个1，10表示继续的俩位有2个1。那么说明input的前4位有1+2=3个1

            接下来的步骤二就是看下如何把前四位0110合并起来，把 01 + 10 加起来变成 0011.

            那么看下 0110 ，跟 0011与运算，剩下了后面的 10，然后右移2位就是前面的两个数字01，再与0011去与，然后加起来就变成了 0011了。


step2:

            0110 0101 0101 0101 0001 0001 1010 0001 ( i )

            0001 1001 0101 0101 0100 0100 0110 1000 ( i>> 2 )   

            0010 0001 0001 0001 0001 0001 0010 0001 ( i & 0x33333333 )     

            0001 0001 0001 0001 0000 0000 0010 0000 ( ( i >> 2) & & 0x33333333 )

            0011 0010 0010 0010 0001 0001 0100 0001 (+)

            剖析下前面4位 0011，表示input的前4位有3个1，前8位 0011 0010 表明，input的前4位有3个1，接下去的4位有2个1，那么前8位总共有3+2=5个1

            接下来的步骤就是把前8位，接下去8位合并起来  0011 0010 0010 0010，用4位表示8位，

            前8位也就是 0011 + 0010 = 0101 5个1 ，接下去8位  0010 + 0010 = 0100 4个1，那么右移4位和1111进行与运算，然后相加可以完成该步骤。


step3:

            0011 0010 0010 0010 0001 0001 0100 0001 ( i )

            0000 0011 0010 0010 0010 0001 0001 0100 ( i >> 4)      

            0000 0010 0000 0010 0000 0001 0000 0001( i & 0x0F0F0F0F)

            0000 0011 0000 0010 0000 0001 0000 0100 ((i >> 4) & 0x0F0F0F0F))

            0000 0101 0000 0100 0000 0010 0000 0101 (+)

            第三步计算完后，分成了四组，每组八个二进制位，只要求出每组上二进制表示的值，相加的结果就是汉明重量。

            那么意思就是要把  0000 0101+ 0000 0100 + 0000 0010 + 0000 0101 ，那么还是可以用之前的方法右移8位，然后和 1111 1111 做与运算然后相加，也就是 0xFFFFFFFF。这样子做是把16位合并成8位，此时由于是对32位二进制进行操作，所以还有一个巧妙的方法：

step4:
            i >> 8

step5:      
            i >> 16
            
Tips:
0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为1，奇数位为0）
0xcccccccc = 11001100110011001100110011001100 (0和1每隔两位交替出现)

0x55555555 = 1010101010101010101010101010101 (偶数位为0，奇数位为1）
0x33333333 = 110011001100110011001100110011 (1和0每隔两位交替出现)
0xf0f0f0f0 = 11110000111100001111000011110000 (0和1每隔四位交替出现)
0x0f0f0f0f = 00001111000011110000111100001111 (1和0每隔四位交替出现)
"""


class NumberOf1Bits(object):

    def hammingWeight(self, n):
        """
        其实可以理解为归并的处理，
        先计算每两位的1的个数，
        再计算每四位的1的个数，
        再计算每八位的1的个数，
        再计算每十六位的1的个数，
        再计算两个十六位的1的个数之和就是32位中1的个数。
        :type n: int
        :rtype: int
        """
        n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
        n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
        n = (n + (n >> 4)) & 0x0f0f0f0f
        n = (n + (n >> 8)) & 0x00ff00ff
        n = n + (n >> 16) & 0x0000ffff
        return n
